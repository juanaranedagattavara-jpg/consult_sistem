---
phase: 01-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/schema.ts
  - convex/auth.config.ts
  - convex/auth.ts
  - convex/users.ts
  - convex/clinics.ts
  - convex/emails.ts
  - convex/http.ts
autonomous: true

must_haves:
  truths:
    - "User can register with email, password, clinic name, phone"
    - "Email verification code is sent on registration"
    - "User can login with valid credentials"
    - "User can request password reset"
    - "Clinic is created automatically on admin registration"
    - "User roles (admin, staff) are stored and retrievable"
  artifacts:
    - path: "convex/schema.ts"
      provides: "Database schema for users, clinics, memberships"
      contains: "defineSchema"
    - path: "convex/auth.config.ts"
      provides: "Auth configuration with Password provider"
      contains: "Password"
    - path: "convex/auth.ts"
      provides: "Auth functions"
      exports: ["auth", "signIn", "signOut"]
    - path: "convex/users.ts"
      provides: "User queries and mutations"
      exports: ["getCurrentUser", "getUserRole"]
    - path: "convex/clinics.ts"
      provides: "Clinic queries and mutations"
      exports: ["createClinic", "getClinic"]
  key_links:
    - from: "convex/auth.ts"
      to: "convex/schema.ts"
      via: "users table reference"
      pattern: "users"
    - from: "convex/clinics.ts"
      to: "convex/schema.ts"
      via: "clinics table reference"
      pattern: "clinics"
---

<objective>
Implement the complete authentication backend with Convex including multi-tenant schema, user registration, email verification, and password reset flows.

Purpose: Provide the authentication infrastructure that all protected features depend on.
Output: Working Convex backend with auth, users, clinics, and email verification.
</objective>

<context>
Stack: Convex + @convex-dev/auth + Resend

Key patterns from research:
- Use @convex-dev/auth Password provider
- Multi-tenant: clinicId on all tables
- Admin registers solo, creates clinic
- Staff invited by admin (link with token)
- Email verification with 6-digit code
- "Remember me" extends session to 30 days

Schema design:
- users: id, email, name, emailVerified, createdAt
- clinics: id, name, phone, ownerId, botConfig, timeConfig, patientFields, createdAt
- clinicMemberships: userId, clinicId, role (admin|staff), invitedAt, acceptedAt
- verificationCodes: userId, code, type (email|reset), expiresAt
- staffInvitations: clinicId, email, role, token, expiresAt, acceptedAt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Convex schema with multi-tenant structure</name>
  <files>
    convex/schema.ts
  </files>
  <action>
    Create convex/schema.ts with complete multi-tenant schema:

    ```typescript
    import { defineSchema, defineTable } from "convex/server";
    import { v } from "convex/values";
    import { authTables } from "@convex-dev/auth/server";

    export default defineSchema({
      ...authTables,

      // Extended user profile (linked to auth users)
      userProfiles: defineTable({
        userId: v.id("users"), // from authTables
        name: v.string(),
        phone: v.optional(v.string()),
        emailVerified: v.boolean(),
        createdAt: v.number(),
      }).index("by_userId", ["userId"]),

      // Clinics (tenants)
      clinics: defineTable({
        name: v.string(),
        phone: v.string(),
        ownerId: v.id("users"),
        // Bot configuration
        botConfig: v.optional(v.object({
          enabled: v.boolean(),
          welcomeMessage: v.optional(v.string()),
          language: v.optional(v.string()),
        })),
        // Time configuration
        timeConfig: v.optional(v.object({
          timezone: v.string(),
          workingHours: v.object({
            start: v.string(), // "09:00"
            end: v.string(),   // "18:00"
          }),
          appointmentDuration: v.number(), // minutes
          bufferTime: v.number(), // minutes between appointments
        })),
        // Custom patient fields
        patientFields: v.optional(v.array(v.object({
          id: v.string(),
          name: v.string(),
          type: v.union(v.literal("text"), v.literal("number"), v.literal("date"), v.literal("select")),
          required: v.boolean(),
          options: v.optional(v.array(v.string())), // for select type
        }))),
        createdAt: v.number(),
      }).index("by_ownerId", ["ownerId"]),

      // Clinic memberships (user-clinic relationship with role)
      clinicMemberships: defineTable({
        userId: v.id("users"),
        clinicId: v.id("clinics"),
        role: v.union(v.literal("admin"), v.literal("staff")),
        invitedAt: v.optional(v.number()),
        acceptedAt: v.optional(v.number()),
      })
        .index("by_userId", ["userId"])
        .index("by_clinicId", ["clinicId"])
        .index("by_userId_clinicId", ["userId", "clinicId"]),

      // Verification codes (email verification, password reset)
      verificationCodes: defineTable({
        userId: v.id("users"),
        code: v.string(), // 6-digit code
        type: v.union(v.literal("email"), v.literal("reset")),
        expiresAt: v.number(),
        used: v.boolean(),
      })
        .index("by_userId_type", ["userId", "type"])
        .index("by_code", ["code"]),

      // Staff invitations
      staffInvitations: defineTable({
        clinicId: v.id("clinics"),
        email: v.string(),
        role: v.union(v.literal("admin"), v.literal("staff")),
        token: v.string(), // UUID for invitation link
        invitedBy: v.id("users"),
        expiresAt: v.number(),
        acceptedAt: v.optional(v.number()),
      })
        .index("by_clinicId", ["clinicId"])
        .index("by_token", ["token"])
        .index("by_email", ["email"]),
    });
    ```
  </action>
  <verify>
    - npx convex dev runs without schema errors
    - All tables created in Convex dashboard
  </verify>
  <done>
    Multi-tenant schema with users, clinics, memberships, verification codes, and invitations defined
  </done>
</task>

<task type="auto">
  <name>Task 2: Configure auth with Password provider</name>
  <files>
    convex/auth.config.ts
    convex/auth.ts
    convex/http.ts
  </files>
  <action>
    1. Create convex/auth.config.ts:
    ```typescript
    import { Password } from "@convex-dev/auth/providers/Password";
    import { convexAuth } from "@convex-dev/auth/server";

    const CustomPassword = Password({
      profile(params) {
        return {
          email: params.email as string,
          name: params.name as string,
        };
      },
      validatePassword(password: string) {
        // Minimum 8 characters, at least one letter and one number
        if (password.length < 8) {
          throw new Error("Password must be at least 8 characters");
        }
        if (!/[a-zA-Z]/.test(password)) {
          throw new Error("Password must contain at least one letter");
        }
        if (!/[0-9]/.test(password)) {
          throw new Error("Password must contain at least one number");
        }
      },
    });

    export const { auth, signIn, signOut, store } = convexAuth({
      providers: [CustomPassword],
    });
    ```

    2. Create convex/auth.ts with auth utilities:
    ```typescript
    import { query, mutation } from "./_generated/server";
    import { auth } from "./auth.config";
    import { v } from "convex/values";

    // Get current authenticated user
    export const currentUser = query({
      args: {},
      handler: async (ctx) => {
        const userId = await auth.getUserId(ctx);
        if (!userId) return null;

        const user = await ctx.db.get(userId);
        if (!user) return null;

        // Get user profile
        const profile = await ctx.db
          .query("userProfiles")
          .withIndex("by_userId", (q) => q.eq("userId", userId))
          .unique();

        // Get user's clinic membership
        const membership = await ctx.db
          .query("clinicMemberships")
          .withIndex("by_userId", (q) => q.eq("userId", userId))
          .first();

        let clinic = null;
        if (membership) {
          clinic = await ctx.db.get(membership.clinicId);
        }

        return {
          id: userId,
          email: user.email,
          name: profile?.name,
          emailVerified: profile?.emailVerified ?? false,
          role: membership?.role ?? null,
          clinicId: membership?.clinicId ?? null,
          clinic: clinic ? { id: clinic._id, name: clinic.name } : null,
        };
      },
    });

    // Check if user is authenticated
    export const isAuthenticated = query({
      args: {},
      handler: async (ctx) => {
        const userId = await auth.getUserId(ctx);
        return userId !== null;
      },
    });
    ```

    3. Create convex/http.ts for auth endpoints:
    ```typescript
    import { httpRouter } from "convex/server";
    import { auth } from "./auth.config";

    const http = httpRouter();

    auth.addHttpRoutes(http);

    export default http;
    ```
  </action>
  <verify>
    - npx convex dev runs without errors
    - Auth endpoints available at Convex HTTP routes
  </verify>
  <done>
    Auth configured with Password provider, validation rules, and HTTP routes
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement user and clinic management functions</name>
  <files>
    convex/users.ts
    convex/clinics.ts
    convex/emails.ts
  </files>
  <action>
    1. Create convex/users.ts:
    ```typescript
    import { query, mutation, internalMutation } from "./_generated/server";
    import { v } from "convex/values";
    import { auth } from "./auth.config";

    // Create user profile after registration
    export const createUserProfile = mutation({
      args: {
        name: v.string(),
        phone: v.optional(v.string()),
        clinicName: v.string(),
        clinicPhone: v.string(),
      },
      handler: async (ctx, args) => {
        const userId = await auth.getUserId(ctx);
        if (!userId) throw new Error("Not authenticated");

        // Check if profile already exists
        const existingProfile = await ctx.db
          .query("userProfiles")
          .withIndex("by_userId", (q) => q.eq("userId", userId))
          .unique();

        if (existingProfile) {
          throw new Error("Profile already exists");
        }

        // Create user profile
        await ctx.db.insert("userProfiles", {
          userId,
          name: args.name,
          phone: args.phone,
          emailVerified: false,
          createdAt: Date.now(),
        });

        // Create clinic
        const clinicId = await ctx.db.insert("clinics", {
          name: args.clinicName,
          phone: args.clinicPhone,
          ownerId: userId,
          createdAt: Date.now(),
        });

        // Create membership as admin
        await ctx.db.insert("clinicMemberships", {
          userId,
          clinicId,
          role: "admin",
          acceptedAt: Date.now(),
        });

        return { clinicId };
      },
    });

    // Get user's role in current clinic
    export const getUserRole = query({
      args: {},
      handler: async (ctx) => {
        const userId = await auth.getUserId(ctx);
        if (!userId) return null;

        const membership = await ctx.db
          .query("clinicMemberships")
          .withIndex("by_userId", (q) => q.eq("userId", userId))
          .first();

        return membership?.role ?? null;
      },
    });

    // Mark email as verified
    export const markEmailVerified = mutation({
      args: {},
      handler: async (ctx) => {
        const userId = await auth.getUserId(ctx);
        if (!userId) throw new Error("Not authenticated");

        const profile = await ctx.db
          .query("userProfiles")
          .withIndex("by_userId", (q) => q.eq("userId", userId))
          .unique();

        if (profile) {
          await ctx.db.patch(profile._id, { emailVerified: true });
        }
      },
    });
    ```

    2. Create convex/clinics.ts:
    ```typescript
    import { query, mutation } from "./_generated/server";
    import { v } from "convex/values";
    import { auth } from "./auth.config";

    // Get current user's clinic
    export const getCurrentClinic = query({
      args: {},
      handler: async (ctx) => {
        const userId = await auth.getUserId(ctx);
        if (!userId) return null;

        const membership = await ctx.db
          .query("clinicMemberships")
          .withIndex("by_userId", (q) => q.eq("userId", userId))
          .first();

        if (!membership) return null;

        const clinic = await ctx.db.get(membership.clinicId);
        return clinic;
      },
    });

    // Update clinic settings (admin only)
    export const updateClinic = mutation({
      args: {
        name: v.optional(v.string()),
        phone: v.optional(v.string()),
        botConfig: v.optional(v.object({
          enabled: v.boolean(),
          welcomeMessage: v.optional(v.string()),
          language: v.optional(v.string()),
        })),
        timeConfig: v.optional(v.object({
          timezone: v.string(),
          workingHours: v.object({
            start: v.string(),
            end: v.string(),
          }),
          appointmentDuration: v.number(),
          bufferTime: v.number(),
        })),
        patientFields: v.optional(v.array(v.object({
          id: v.string(),
          name: v.string(),
          type: v.union(v.literal("text"), v.literal("number"), v.literal("date"), v.literal("select")),
          required: v.boolean(),
          options: v.optional(v.array(v.string())),
        }))),
      },
      handler: async (ctx, args) => {
        const userId = await auth.getUserId(ctx);
        if (!userId) throw new Error("Not authenticated");

        const membership = await ctx.db
          .query("clinicMemberships")
          .withIndex("by_userId", (q) => q.eq("userId", userId))
          .first();

        if (!membership || membership.role !== "admin") {
          throw new Error("Only admins can update clinic settings");
        }

        const updates: Record<string, unknown> = {};
        if (args.name !== undefined) updates.name = args.name;
        if (args.phone !== undefined) updates.phone = args.phone;
        if (args.botConfig !== undefined) updates.botConfig = args.botConfig;
        if (args.timeConfig !== undefined) updates.timeConfig = args.timeConfig;
        if (args.patientFields !== undefined) updates.patientFields = args.patientFields;

        await ctx.db.patch(membership.clinicId, updates);
        return { success: true };
      },
    });

    // Invite staff member
    export const inviteStaff = mutation({
      args: {
        email: v.string(),
        role: v.union(v.literal("admin"), v.literal("staff")),
      },
      handler: async (ctx, args) => {
        const userId = await auth.getUserId(ctx);
        if (!userId) throw new Error("Not authenticated");

        const membership = await ctx.db
          .query("clinicMemberships")
          .withIndex("by_userId", (q) => q.eq("userId", userId))
          .first();

        if (!membership || membership.role !== "admin") {
          throw new Error("Only admins can invite staff");
        }

        // Generate unique token
        const token = crypto.randomUUID();
        const expiresAt = Date.now() + 7 * 24 * 60 * 60 * 1000; // 7 days

        await ctx.db.insert("staffInvitations", {
          clinicId: membership.clinicId,
          email: args.email,
          role: args.role,
          token,
          invitedBy: userId,
          expiresAt,
        });

        return { token, expiresAt };
      },
    });

    // Accept staff invitation
    export const acceptInvitation = mutation({
      args: {
        token: v.string(),
      },
      handler: async (ctx, args) => {
        const userId = await auth.getUserId(ctx);
        if (!userId) throw new Error("Not authenticated");

        const invitation = await ctx.db
          .query("staffInvitations")
          .withIndex("by_token", (q) => q.eq("token", args.token))
          .unique();

        if (!invitation) {
          throw new Error("Invalid invitation");
        }

        if (invitation.acceptedAt) {
          throw new Error("Invitation already used");
        }

        if (Date.now() > invitation.expiresAt) {
          throw new Error("Invitation expired");
        }

        // Create membership
        await ctx.db.insert("clinicMemberships", {
          userId,
          clinicId: invitation.clinicId,
          role: invitation.role,
          invitedAt: invitation.expiresAt - 7 * 24 * 60 * 60 * 1000,
          acceptedAt: Date.now(),
        });

        // Mark invitation as accepted
        await ctx.db.patch(invitation._id, { acceptedAt: Date.now() });

        return { clinicId: invitation.clinicId };
      },
    });

    // Get clinic staff list (admin only)
    export const getClinicStaff = query({
      args: {},
      handler: async (ctx) => {
        const userId = await auth.getUserId(ctx);
        if (!userId) return [];

        const membership = await ctx.db
          .query("clinicMemberships")
          .withIndex("by_userId", (q) => q.eq("userId", userId))
          .first();

        if (!membership || membership.role !== "admin") {
          return [];
        }

        const memberships = await ctx.db
          .query("clinicMemberships")
          .withIndex("by_clinicId", (q) => q.eq("clinicId", membership.clinicId))
          .collect();

        const staffList = await Promise.all(
          memberships.map(async (m) => {
            const user = await ctx.db.get(m.userId);
            const profile = await ctx.db
              .query("userProfiles")
              .withIndex("by_userId", (q) => q.eq("userId", m.userId))
              .unique();

            return {
              id: m.userId,
              email: user?.email,
              name: profile?.name,
              role: m.role,
              acceptedAt: m.acceptedAt,
            };
          })
        );

        return staffList;
      },
    });
    ```

    3. Create convex/emails.ts for verification codes:
    ```typescript
    import { mutation, query, internalAction } from "./_generated/server";
    import { v } from "convex/values";
    import { auth } from "./auth.config";
    import { internal } from "./_generated/api";

    // Generate 6-digit verification code
    function generateCode(): string {
      return Math.floor(100000 + Math.random() * 900000).toString();
    }

    // Create verification code
    export const createVerificationCode = mutation({
      args: {
        type: v.union(v.literal("email"), v.literal("reset")),
      },
      handler: async (ctx, args) => {
        const userId = await auth.getUserId(ctx);
        if (!userId) throw new Error("Not authenticated");

        const code = generateCode();
        const expiresAt = Date.now() + 15 * 60 * 1000; // 15 minutes

        // Delete any existing codes of this type for this user
        const existingCodes = await ctx.db
          .query("verificationCodes")
          .withIndex("by_userId_type", (q) =>
            q.eq("userId", userId).eq("type", args.type)
          )
          .collect();

        for (const existing of existingCodes) {
          await ctx.db.delete(existing._id);
        }

        // Create new code
        await ctx.db.insert("verificationCodes", {
          userId,
          code,
          type: args.type,
          expiresAt,
          used: false,
        });

        return { code }; // In production, send via email, don't return
      },
    });

    // Verify code
    export const verifyCode = mutation({
      args: {
        code: v.string(),
        type: v.union(v.literal("email"), v.literal("reset")),
      },
      handler: async (ctx, args) => {
        const userId = await auth.getUserId(ctx);
        if (!userId) throw new Error("Not authenticated");

        const verification = await ctx.db
          .query("verificationCodes")
          .withIndex("by_userId_type", (q) =>
            q.eq("userId", userId).eq("type", args.type)
          )
          .first();

        if (!verification) {
          throw new Error("No verification code found");
        }

        if (verification.used) {
          throw new Error("Code already used");
        }

        if (Date.now() > verification.expiresAt) {
          throw new Error("Code expired");
        }

        if (verification.code !== args.code) {
          throw new Error("Invalid code");
        }

        // Mark as used
        await ctx.db.patch(verification._id, { used: true });

        // If email verification, mark email as verified
        if (args.type === "email") {
          const profile = await ctx.db
            .query("userProfiles")
            .withIndex("by_userId", (q) => q.eq("userId", userId))
            .unique();

          if (profile) {
            await ctx.db.patch(profile._id, { emailVerified: true });
          }
        }

        return { success: true };
      },
    });

    // Create reset code by email (for forgot password - no auth required)
    export const createResetCodeByEmail = mutation({
      args: {
        email: v.string(),
      },
      handler: async (ctx, args) => {
        // Find user by email in the auth users table
        // Note: This is a simplified version. In production, you'd need to
        // query the authTables properly or use a custom index

        // For now, return success regardless to prevent email enumeration
        // The actual email sending would happen via Resend in an action

        return { success: true, message: "If the email exists, a reset code was sent" };
      },
    });
    ```
  </action>
  <verify>
    - npx convex dev deploys without errors
    - Queries and mutations appear in Convex dashboard
    - Can test createUserProfile and getCurrentClinic in dashboard
  </verify>
  <done>
    User registration with clinic creation, role management, staff invitations, and email verification flows implemented
  </done>
</task>

</tasks>

<verification>
1. Run `npx convex dev` - all functions deploy successfully
2. Check Convex dashboard - tables and functions visible
3. Test in dashboard:
   - Schema has all required tables
   - auth.config.ts password validation works (try weak passwords)
   - createVerificationCode generates 6-digit codes
</verification>

<success_criteria>
- Multi-tenant schema deployed with all tables
- Password provider configured with validation rules
- User registration creates profile + clinic + admin membership
- Verification code generation and validation works
- Staff invitation system with token-based links
- Role-based queries (admin vs staff) implemented
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
