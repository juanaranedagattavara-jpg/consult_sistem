---
phase: 02-professionals-services-calendar
plan: 05
type: execute
wave: 2
depends_on: ["02-02"]
files_modified:
  - convex/services.ts
autonomous: true

must_haves:
  truths:
    - "Can create service with category, duration, price"
    - "Can list services by clinic or category"
    - "Can toggle service active/inactive"
    - "Can duplicate service as template"
    - "Can reorder services within category"
  artifacts:
    - path: "convex/services.ts"
      provides: "CRUD mutations and queries for services"
      exports: ["create", "list", "listByCategory", "get", "update", "remove", "toggleActive", "duplicate", "reorder"]
  key_links:
    - from: "convex/services.ts"
      to: "convex/schema.ts:services"
      via: "ctx.db operations"
      pattern: "ctx.db"
---

<objective>
Create services CRUD mutations and queries.

Purpose: Backend operations for managing services - services belong to categories, have duration/price, and can be duplicated.
Output: convex/services.ts with full CRUD + duplicate + reorder functionality.
</objective>

<execution_context>
@C:\Users\juana\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\juana\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-professionals-services-calendar/CONTEXT.md
@convex/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create services.ts with CRUD operations</name>
  <files>convex/services.ts</files>
  <action>
Create convex/services.ts with full CRUD:

```typescript
import { v } from "convex/values";
import { mutation, query } from "./_generated/server";

// List all services for a clinic
export const list = query({
  args: { clinicId: v.id("clinics") },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("services")
      .withIndex("by_clinic", (q) => q.eq("clinicId", args.clinicId))
      .collect();
  },
});

// List active services only
export const listActive = query({
  args: { clinicId: v.id("clinics") },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("services")
      .withIndex("by_clinic_active", (q) =>
        q.eq("clinicId", args.clinicId).eq("active", true)
      )
      .collect();
  },
});

// List services by category, ordered
export const listByCategory = query({
  args: { categoryId: v.id("serviceCategories") },
  handler: async (ctx, args) => {
    const services = await ctx.db
      .query("services")
      .withIndex("by_category", (q) => q.eq("categoryId", args.categoryId))
      .collect();
    // Sort by order field
    return services.sort((a, b) => a.order - b.order);
  },
});

// Get single service
export const get = query({
  args: { serviceId: v.id("services") },
  handler: async (ctx, args) => {
    return await ctx.db.get(args.serviceId);
  },
});

// Create new service
export const create = mutation({
  args: {
    clinicId: v.id("clinics"),
    categoryId: v.id("serviceCategories"),
    name: v.string(),
    description: v.optional(v.string()),
    duration: v.number(), // minutes
    price: v.optional(v.number()),
    color: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    // Get highest order in this category
    const existing = await ctx.db
      .query("services")
      .withIndex("by_category", (q) => q.eq("categoryId", args.categoryId))
      .collect();
    const maxOrder = existing.length > 0
      ? Math.max(...existing.map(s => s.order))
      : -1;

    const now = Date.now();
    return await ctx.db.insert("services", {
      clinicId: args.clinicId,
      categoryId: args.categoryId,
      name: args.name,
      description: args.description,
      duration: args.duration,
      price: args.price,
      color: args.color,
      order: maxOrder + 1,
      active: true, // New services are active by default
      createdAt: now,
      updatedAt: now,
    });
  },
});

// Update service
export const update = mutation({
  args: {
    serviceId: v.id("services"),
    categoryId: v.optional(v.id("serviceCategories")),
    name: v.optional(v.string()),
    description: v.optional(v.string()),
    duration: v.optional(v.number()),
    price: v.optional(v.number()),
    color: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const { serviceId, ...updates } = args;
    // Filter out undefined values
    const patch: Record<string, unknown> = { updatedAt: Date.now() };
    if (updates.categoryId !== undefined) patch.categoryId = updates.categoryId;
    if (updates.name !== undefined) patch.name = updates.name;
    if (updates.description !== undefined) patch.description = updates.description;
    if (updates.duration !== undefined) patch.duration = updates.duration;
    if (updates.price !== undefined) patch.price = updates.price;
    if (updates.color !== undefined) patch.color = updates.color;

    await ctx.db.patch(serviceId, patch);
  },
});

// Toggle active status
export const toggleActive = mutation({
  args: { serviceId: v.id("services") },
  handler: async (ctx, args) => {
    const service = await ctx.db.get(args.serviceId);
    if (!service) throw new Error("Servicio no encontrado");

    await ctx.db.patch(args.serviceId, {
      active: !service.active,
      updatedAt: Date.now(),
    });
  },
});

// Delete service (soft delete could be used instead, but we have active toggle)
export const remove = mutation({
  args: { serviceId: v.id("services") },
  handler: async (ctx, args) => {
    // Note: CONTEXT.md says deletion is allowed but show warning about professionals
    // The warning is handled in UI, not here
    await ctx.db.delete(args.serviceId);
  },
});

// Duplicate service (as template)
export const duplicate = mutation({
  args: { serviceId: v.id("services") },
  handler: async (ctx, args) => {
    const original = await ctx.db.get(args.serviceId);
    if (!original) throw new Error("Servicio no encontrado");

    // Get highest order in this category
    const existing = await ctx.db
      .query("services")
      .withIndex("by_category", (q) => q.eq("categoryId", original.categoryId))
      .collect();
    const maxOrder = Math.max(...existing.map(s => s.order), -1);

    const now = Date.now();
    return await ctx.db.insert("services", {
      clinicId: original.clinicId,
      categoryId: original.categoryId,
      name: `${original.name} (copia)`,
      description: original.description,
      duration: original.duration,
      price: original.price,
      color: original.color,
      order: maxOrder + 1,
      active: true,
      createdAt: now,
      updatedAt: now,
    });
  },
});

// Reorder services within category (after drag-drop)
export const reorder = mutation({
  args: {
    categoryId: v.id("serviceCategories"),
    serviceIds: v.array(v.id("services")), // New order
  },
  handler: async (ctx, args) => {
    const now = Date.now();
    for (let i = 0; i < args.serviceIds.length; i++) {
      await ctx.db.patch(args.serviceIds[i], {
        order: i,
        updatedAt: now,
      });
    }
  },
});

// Bulk toggle active (for batch actions)
export const bulkToggleActive = mutation({
  args: {
    serviceIds: v.array(v.id("services")),
    active: v.boolean(),
  },
  handler: async (ctx, args) => {
    const now = Date.now();
    for (const serviceId of args.serviceIds) {
      await ctx.db.patch(serviceId, {
        active: args.active,
        updatedAt: now,
      });
    }
  },
});
```

Key points:
- listActive uses index for efficient active-only query
- create/duplicate auto-calculate order
- update uses partial patch pattern
- duplicate appends "(copia)" to name
- bulkToggleActive for batch operations
  </action>
  <verify>
Run Convex to verify no TypeScript errors:
```bash
npx convex dev --once
```
  </verify>
  <done>services.ts exports all CRUD operations plus duplicate, reorder, bulkToggleActive</done>
</task>

</tasks>

<verification>
1. `cat convex/services.ts` shows all functions
2. `npx convex dev --once` succeeds
3. Functions handle ordering and category relationships correctly
</verification>

<success_criteria>
- list and listActive queries work with proper indexes
- create auto-assigns order and defaults active=true
- duplicate creates copy with "(copia)" suffix
- reorder updates order for all services in array
- bulkToggleActive allows batch status changes
</success_criteria>

<output>
After completion, create `.planning/phases/02-professionals-services-calendar/02-05-SUMMARY.md`
</output>
