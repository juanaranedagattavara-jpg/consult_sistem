---
phase: 02-professionals-services-calendar
plan: 11
type: execute
wave: 4
depends_on: ["02-02", "02-03"]
files_modified:
  - convex/lib/availability.ts
autonomous: true

must_haves:
  truths:
    - "Can generate time slots for a day based on schedule"
    - "Can filter slots by lunch break"
    - "Can filter slots by exceptions"
    - "Can check if slot overlaps with events"
  artifacts:
    - path: "convex/lib/availability.ts"
      provides: "Availability calculation helpers"
      exports: ["generateSlots", "calculateAvailableSlots"]
      min_lines: 80
  key_links: []
---

<objective>
Create availability calculation helpers for slot generation.

Purpose: Core algorithm for determining available appointment slots - considers schedules, lunch breaks, exceptions, and calendar events.
Output: convex/lib/availability.ts with pure functions for slot calculation.
</objective>

<execution_context>
@C:\Users\juana\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\juana\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-professionals-services-calendar/CONTEXT.md
@.planning/phases/02-professionals-services-calendar/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create availability calculation helpers</name>
  <files>convex/lib/availability.ts</files>
  <action>
Create convex/lib/availability.ts with slot generation and filtering:

```typescript
// Types for availability calculation
export interface TimeSlot {
  start: string; // "09:00" HH:mm
  end: string;   // "09:30" HH:mm
}

export interface DaySchedule {
  enabled: boolean;
  start: string;
  end: string;
  lunch?: {
    start: string;
    end: string;
  };
}

export interface CalendarEvent {
  start: string; // ISO datetime or "HH:mm"
  end: string;   // ISO datetime or "HH:mm"
}

export interface Exception {
  startDate: string; // YYYY-MM-DD
  endDate: string;   // YYYY-MM-DD
}

// Convert "HH:mm" to minutes since midnight
export function timeToMinutes(time: string): number {
  const [hours, minutes] = time.split(":").map(Number);
  return hours * 60 + minutes;
}

// Convert minutes since midnight to "HH:mm"
export function minutesToTime(minutes: number): string {
  const h = Math.floor(minutes / 60);
  const m = minutes % 60;
  return `${h.toString().padStart(2, "0")}:${m.toString().padStart(2, "0")}`;
}

// Get day name from date (for schedule lookup)
export function getDayName(date: string): string {
  const d = new Date(date + "T00:00:00");
  const days = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
  return days[d.getDay()];
}

// Check if date falls within exception range
export function isDateExcepted(date: string, exceptions: Exception[]): boolean {
  return exceptions.some(
    (exc) => date >= exc.startDate && date <= exc.endDate
  );
}

// Generate all possible slots for a schedule
export function generateSlots(
  schedule: DaySchedule,
  intervalMinutes: number = 30
): TimeSlot[] {
  if (!schedule.enabled) return [];

  const slots: TimeSlot[] = [];
  const startMinutes = timeToMinutes(schedule.start);
  const endMinutes = timeToMinutes(schedule.end);

  for (let current = startMinutes; current < endMinutes; current += intervalMinutes) {
    slots.push({
      start: minutesToTime(current),
      end: minutesToTime(current + intervalMinutes),
    });
  }

  return slots;
}

// Filter out slots that overlap with lunch
export function filterLunchSlots(slots: TimeSlot[], lunch?: { start: string; end: string }): TimeSlot[] {
  if (!lunch) return slots;

  const lunchStart = timeToMinutes(lunch.start);
  const lunchEnd = timeToMinutes(lunch.end);

  return slots.filter((slot) => {
    const slotStart = timeToMinutes(slot.start);
    const slotEnd = timeToMinutes(slot.end);
    // Slot is valid if it ends before lunch starts OR starts after lunch ends
    return slotEnd <= lunchStart || slotStart >= lunchEnd;
  });
}

// Extract time from ISO datetime string
export function extractTime(isoOrTime: string): string {
  if (isoOrTime.includes("T")) {
    // ISO format: "2024-02-04T10:00:00-03:00"
    const timePart = isoOrTime.split("T")[1];
    return timePart.substring(0, 5); // "10:00"
  }
  // Already HH:mm format
  return isoOrTime;
}

// Check if slot overlaps with a calendar event
export function slotOverlapsEvent(
  slot: TimeSlot,
  serviceDuration: number,
  event: CalendarEvent
): boolean {
  const slotStart = timeToMinutes(slot.start);
  const slotEnd = slotStart + serviceDuration;
  const eventStart = timeToMinutes(extractTime(event.start));
  const eventEnd = timeToMinutes(extractTime(event.end));

  // Overlap if slot starts before event ends AND slot ends after event starts
  return slotStart < eventEnd && slotEnd > eventStart;
}

// Filter slots that overlap with events
export function filterEventSlots(
  slots: TimeSlot[],
  serviceDuration: number,
  events: CalendarEvent[]
): TimeSlot[] {
  return slots.filter((slot) =>
    !events.some((event) => slotOverlapsEvent(slot, serviceDuration, event))
  );
}

// Filter slots where service duration fits before schedule end
export function filterByDuration(
  slots: TimeSlot[],
  serviceDuration: number,
  scheduleEnd: string
): TimeSlot[] {
  const endMinutes = timeToMinutes(scheduleEnd);
  return slots.filter((slot) => {
    const slotEnd = timeToMinutes(slot.start) + serviceDuration;
    return slotEnd <= endMinutes;
  });
}

// Main function: calculate available slots for a day
export function calculateAvailableSlots(
  date: string, // YYYY-MM-DD
  serviceDuration: number, // minutes
  professionalSchedule: DaySchedule | null,
  clinicSchedule: DaySchedule,
  exceptions: Exception[],
  calendarEvents: CalendarEvent[],
  existingAppointments: CalendarEvent[],
  intervalMinutes: number = 30
): TimeSlot[] {
  // 1. Check if date is excepted (vacation, holiday)
  if (isDateExcepted(date, exceptions)) {
    return [];
  }

  // 2. Get schedule (professional override or clinic default)
  const schedule = professionalSchedule ?? clinicSchedule;
  if (!schedule.enabled) {
    return [];
  }

  // 3. Generate all possible slots
  let slots = generateSlots(schedule, intervalMinutes);

  // 4. Remove lunch break slots
  slots = filterLunchSlots(slots, schedule.lunch);

  // 5. Remove slots that overlap with calendar events
  slots = filterEventSlots(slots, serviceDuration, calendarEvents);

  // 6. Remove slots that overlap with existing appointments
  slots = filterEventSlots(slots, serviceDuration, existingAppointments);

  // 7. Filter slots where service fits before end of day
  slots = filterByDuration(slots, serviceDuration, schedule.end);

  return slots;
}
```

Key points:
- Pure functions for easy testing
- Uses minutes for calculations (avoids Date complexity)
- Handles both HH:mm and ISO datetime formats
- Each filter is separate (composable)
- Main calculateAvailableSlots combines all filters
  </action>
  <verify>
Run Convex to verify no TypeScript errors:
```bash
npx convex dev --once
```
  </verify>
  <done>availability.ts exports pure functions for slot calculation</done>
</task>

</tasks>

<verification>
1. `cat convex/lib/availability.ts` shows all helper functions
2. `npx convex dev --once` succeeds
3. calculateAvailableSlots implements full algorithm from CONTEXT.md
</verification>

<success_criteria>
- generateSlots creates slots based on schedule
- filterLunchSlots removes lunch overlap
- filterEventSlots removes calendar event overlap
- calculateAvailableSlots combines all filters
- Functions are pure (no side effects)
</success_criteria>

<output>
After completion, create `.planning/phases/02-professionals-services-calendar/02-11-SUMMARY.md`
</output>
