---
phase: 02-professionals-services-calendar
plan: 06
type: execute
wave: 2
depends_on: ["02-03"]
files_modified:
  - convex/professionals.ts
autonomous: true

must_haves:
  truths:
    - "Can create professional with all required fields"
    - "Can list professionals by clinic with filters"
    - "Can update professional including calendarId"
    - "Can toggle professional active/inactive"
    - "Email uniqueness is validated"
  artifacts:
    - path: "convex/professionals.ts"
      provides: "CRUD mutations and queries for professionals"
      exports: ["create", "list", "listActive", "get", "update", "remove", "toggleActive", "bulkToggleActive"]
  key_links:
    - from: "convex/professionals.ts"
      to: "convex/schema.ts:professionals"
      via: "ctx.db operations"
      pattern: "ctx.db"
---

<objective>
Create professionals CRUD mutations and queries.

Purpose: Backend operations for managing medical professionals - includes email validation, schedule override, and calendar connection.
Output: convex/professionals.ts with full CRUD + email validation + bulk operations.
</objective>

<execution_context>
@C:\Users\juana\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\juana\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-professionals-services-calendar/CONTEXT.md
@convex/schema.ts
@convex/lib/validators.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create professionals.ts with CRUD operations</name>
  <files>convex/professionals.ts</files>
  <action>
Create convex/professionals.ts with full CRUD:

```typescript
import { v } from "convex/values";
import { mutation, query } from "./_generated/server";
import { weekScheduleValidator } from "./lib/validators";

// List all professionals for a clinic
export const list = query({
  args: { clinicId: v.id("clinics") },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("professionals")
      .withIndex("by_clinic", (q) => q.eq("clinicId", args.clinicId))
      .collect();
  },
});

// List active professionals only
export const listActive = query({
  args: { clinicId: v.id("clinics") },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("professionals")
      .withIndex("by_clinic_active", (q) =>
        q.eq("clinicId", args.clinicId).eq("active", true)
      )
      .collect();
  },
});

// List with service details populated
export const listWithServices = query({
  args: { clinicId: v.id("clinics") },
  handler: async (ctx, args) => {
    const professionals = await ctx.db
      .query("professionals")
      .withIndex("by_clinic", (q) => q.eq("clinicId", args.clinicId))
      .collect();

    // Populate service names for each professional
    return await Promise.all(
      professionals.map(async (prof) => {
        const services = await Promise.all(
          prof.serviceIds.map((id) => ctx.db.get(id))
        );
        return {
          ...prof,
          services: services.filter(Boolean), // Remove nulls if service was deleted
        };
      })
    );
  },
});

// Get single professional
export const get = query({
  args: { professionalId: v.id("professionals") },
  handler: async (ctx, args) => {
    return await ctx.db.get(args.professionalId);
  },
});

// Get professional with services populated
export const getWithServices = query({
  args: { professionalId: v.id("professionals") },
  handler: async (ctx, args) => {
    const professional = await ctx.db.get(args.professionalId);
    if (!professional) return null;

    const services = await Promise.all(
      professional.serviceIds.map((id) => ctx.db.get(id))
    );

    return {
      ...professional,
      services: services.filter(Boolean),
    };
  },
});

// Create new professional
export const create = mutation({
  args: {
    clinicId: v.id("clinics"),
    name: v.string(),
    email: v.string(),
    phone: v.string(),
    specialty: v.string(),
    color: v.string(),
    serviceIds: v.array(v.id("services")),
    schedule: v.optional(weekScheduleValidator),
    calendarId: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    // Validate email uniqueness globally (per CONTEXT.md)
    const existing = await ctx.db
      .query("professionals")
      .withIndex("by_email", (q) => q.eq("email", args.email))
      .first();

    if (existing) {
      throw new Error("Ya existe un profesional con este email");
    }

    const now = Date.now();
    return await ctx.db.insert("professionals", {
      clinicId: args.clinicId,
      userId: undefined, // Set later if professional creates account
      name: args.name,
      email: args.email,
      phone: args.phone,
      specialty: args.specialty,
      calendarId: args.calendarId,
      color: args.color,
      serviceIds: args.serviceIds,
      schedule: args.schedule,
      active: true, // New professionals are active by default
      createdAt: now,
      updatedAt: now,
    });
  },
});

// Update professional
export const update = mutation({
  args: {
    professionalId: v.id("professionals"),
    name: v.optional(v.string()),
    email: v.optional(v.string()),
    phone: v.optional(v.string()),
    specialty: v.optional(v.string()),
    color: v.optional(v.string()),
    serviceIds: v.optional(v.array(v.id("services"))),
    schedule: v.optional(weekScheduleValidator),
    calendarId: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const { professionalId, ...updates } = args;

    // If email is being changed, validate uniqueness
    if (updates.email) {
      const existing = await ctx.db
        .query("professionals")
        .withIndex("by_email", (q) => q.eq("email", updates.email))
        .first();

      if (existing && existing._id !== professionalId) {
        throw new Error("Ya existe un profesional con este email");
      }
    }

    // Build patch object with only provided fields
    const patch: Record<string, unknown> = { updatedAt: Date.now() };
    if (updates.name !== undefined) patch.name = updates.name;
    if (updates.email !== undefined) patch.email = updates.email;
    if (updates.phone !== undefined) patch.phone = updates.phone;
    if (updates.specialty !== undefined) patch.specialty = updates.specialty;
    if (updates.color !== undefined) patch.color = updates.color;
    if (updates.serviceIds !== undefined) patch.serviceIds = updates.serviceIds;
    if (updates.schedule !== undefined) patch.schedule = updates.schedule;
    if (updates.calendarId !== undefined) patch.calendarId = updates.calendarId;

    await ctx.db.patch(professionalId, patch);
  },
});

// Toggle active status
export const toggleActive = mutation({
  args: { professionalId: v.id("professionals") },
  handler: async (ctx, args) => {
    const professional = await ctx.db.get(args.professionalId);
    if (!professional) throw new Error("Profesional no encontrado");

    await ctx.db.patch(args.professionalId, {
      active: !professional.active,
      updatedAt: Date.now(),
    });
  },
});

// Delete professional (per CONTEXT.md: allowed, show warning about pending appointments in UI)
export const remove = mutation({
  args: { professionalId: v.id("professionals") },
  handler: async (ctx, args) => {
    // Delete associated exceptions first
    const exceptions = await ctx.db
      .query("professionalExceptions")
      .withIndex("by_professional", (q) => q.eq("professionalId", args.professionalId))
      .collect();

    for (const exception of exceptions) {
      await ctx.db.delete(exception._id);
    }

    await ctx.db.delete(args.professionalId);
  },
});

// Bulk toggle active (for batch actions)
export const bulkToggleActive = mutation({
  args: {
    professionalIds: v.array(v.id("professionals")),
    active: v.boolean(),
  },
  handler: async (ctx, args) => {
    const now = Date.now();
    for (const professionalId of args.professionalIds) {
      await ctx.db.patch(professionalId, {
        active: args.active,
        updatedAt: now,
      });
    }
  },
});

// Clear calendar connection
export const disconnectCalendar = mutation({
  args: { professionalId: v.id("professionals") },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.professionalId, {
      calendarId: undefined,
      updatedAt: Date.now(),
    });
  },
});
```

Key points:
- Email uniqueness validated globally (not per-clinic)
- create/update validate email before saving
- listWithServices populates service objects for display
- remove also deletes associated exceptions
- disconnectCalendar allows removing calendar connection
  </action>
  <verify>
Run Convex to verify no TypeScript errors:
```bash
npx convex dev --once
```
  </verify>
  <done>professionals.ts exports all CRUD operations with email validation</done>
</task>

</tasks>

<verification>
1. `cat convex/professionals.ts` shows all functions
2. `npx convex dev --once` succeeds
3. Email validation prevents duplicates globally
</verification>

<success_criteria>
- list and listActive queries work with proper indexes
- create validates email uniqueness globally
- update validates email when changed
- listWithServices populates service details
- remove cascades to delete exceptions
- disconnectCalendar clears calendarId
</success_criteria>

<output>
After completion, create `.planning/phases/02-professionals-services-calendar/02-06-SUMMARY.md`
</output>
