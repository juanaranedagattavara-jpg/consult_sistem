---
phase: 02-professionals-services-calendar
plan: 07
type: execute
wave: 2
depends_on: ["02-03"]
files_modified:
  - convex/professionalExceptions.ts
autonomous: true

must_haves:
  truths:
    - "Can create exception (vacation/absence) for professional"
    - "Can list exceptions for a professional"
    - "Can list exceptions for date range (for availability check)"
    - "Can update and delete exceptions"
  artifacts:
    - path: "convex/professionalExceptions.ts"
      provides: "CRUD for professional exceptions"
      exports: ["create", "list", "listByDateRange", "update", "remove"]
  key_links:
    - from: "convex/professionalExceptions.ts"
      to: "convex/schema.ts:professionalExceptions"
      via: "ctx.db operations"
      pattern: "ctx.db"
---

<objective>
Create professional exceptions CRUD mutations and queries.

Purpose: Backend operations for managing vacations, sick days, and other absences that block availability.
Output: convex/professionalExceptions.ts with CRUD + date range queries for availability calculation.
</objective>

<execution_context>
@C:\Users\juana\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\juana\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-professionals-services-calendar/CONTEXT.md
@convex/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create professionalExceptions.ts with CRUD operations</name>
  <files>convex/professionalExceptions.ts</files>
  <action>
Create convex/professionalExceptions.ts:

```typescript
import { v } from "convex/values";
import { mutation, query } from "./_generated/server";

// List all exceptions for a professional
export const list = query({
  args: { professionalId: v.id("professionals") },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("professionalExceptions")
      .withIndex("by_professional", (q) => q.eq("professionalId", args.professionalId))
      .collect();
  },
});

// List exceptions that overlap with a date (for availability check)
// This checks if the given date falls within any exception range
export const listByDate = query({
  args: {
    professionalId: v.id("professionals"),
    date: v.string(), // YYYY-MM-DD
  },
  handler: async (ctx, args) => {
    // Get all exceptions for this professional
    const exceptions = await ctx.db
      .query("professionalExceptions")
      .withIndex("by_professional", (q) => q.eq("professionalId", args.professionalId))
      .collect();

    // Filter to those that include the given date
    return exceptions.filter(
      (exc) => args.date >= exc.startDate && args.date <= exc.endDate
    );
  },
});

// List exceptions in a date range (for calendar display)
export const listByDateRange = query({
  args: {
    professionalId: v.id("professionals"),
    startDate: v.string(), // YYYY-MM-DD
    endDate: v.string(),   // YYYY-MM-DD
  },
  handler: async (ctx, args) => {
    const exceptions = await ctx.db
      .query("professionalExceptions")
      .withIndex("by_professional", (q) => q.eq("professionalId", args.professionalId))
      .collect();

    // Filter to those that overlap with the range
    return exceptions.filter(
      (exc) =>
        // Exception starts before range ends AND exception ends after range starts
        exc.startDate <= args.endDate && exc.endDate >= args.startDate
    );
  },
});

// Get single exception
export const get = query({
  args: { exceptionId: v.id("professionalExceptions") },
  handler: async (ctx, args) => {
    return await ctx.db.get(args.exceptionId);
  },
});

// Create exception
export const create = mutation({
  args: {
    professionalId: v.id("professionals"),
    startDate: v.string(), // YYYY-MM-DD
    endDate: v.string(),   // YYYY-MM-DD
    reason: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    // Validate dates
    if (args.endDate < args.startDate) {
      throw new Error("La fecha de fin debe ser igual o posterior a la fecha de inicio");
    }

    // Check for overlapping exceptions
    const existing = await ctx.db
      .query("professionalExceptions")
      .withIndex("by_professional", (q) => q.eq("professionalId", args.professionalId))
      .collect();

    const overlaps = existing.some(
      (exc) => args.startDate <= exc.endDate && args.endDate >= exc.startDate
    );

    if (overlaps) {
      throw new Error("Ya existe una excepcion que se superpone con este rango de fechas");
    }

    return await ctx.db.insert("professionalExceptions", {
      professionalId: args.professionalId,
      startDate: args.startDate,
      endDate: args.endDate,
      reason: args.reason,
      createdAt: Date.now(),
    });
  },
});

// Update exception
export const update = mutation({
  args: {
    exceptionId: v.id("professionalExceptions"),
    startDate: v.optional(v.string()),
    endDate: v.optional(v.string()),
    reason: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const { exceptionId, ...updates } = args;

    const exception = await ctx.db.get(exceptionId);
    if (!exception) throw new Error("Excepcion no encontrada");

    const newStartDate = updates.startDate ?? exception.startDate;
    const newEndDate = updates.endDate ?? exception.endDate;

    // Validate dates
    if (newEndDate < newStartDate) {
      throw new Error("La fecha de fin debe ser igual o posterior a la fecha de inicio");
    }

    // Check for overlaps with OTHER exceptions
    const existing = await ctx.db
      .query("professionalExceptions")
      .withIndex("by_professional", (q) => q.eq("professionalId", exception.professionalId))
      .collect();

    const overlaps = existing.some(
      (exc) =>
        exc._id !== exceptionId &&
        newStartDate <= exc.endDate &&
        newEndDate >= exc.startDate
    );

    if (overlaps) {
      throw new Error("Ya existe una excepcion que se superpone con este rango de fechas");
    }

    // Build patch
    const patch: Record<string, unknown> = {};
    if (updates.startDate !== undefined) patch.startDate = updates.startDate;
    if (updates.endDate !== undefined) patch.endDate = updates.endDate;
    if (updates.reason !== undefined) patch.reason = updates.reason;

    if (Object.keys(patch).length > 0) {
      await ctx.db.patch(exceptionId, patch);
    }
  },
});

// Delete exception
export const remove = mutation({
  args: { exceptionId: v.id("professionalExceptions") },
  handler: async (ctx, args) => {
    await ctx.db.delete(args.exceptionId);
  },
});
```

Key points:
- listByDate returns exceptions that include a specific date (for availability)
- listByDateRange returns exceptions overlapping a range (for calendar display)
- create/update validate date order and check for overlaps
- Overlap detection prevents double-booking vacations
  </action>
  <verify>
Run Convex to verify no TypeScript errors:
```bash
npx convex dev --once
```
  </verify>
  <done>professionalExceptions.ts exports all CRUD with date validation</done>
</task>

</tasks>

<verification>
1. `cat convex/professionalExceptions.ts` shows all functions
2. `npx convex dev --once` succeeds
3. Date validation prevents invalid ranges and overlaps
</verification>

<success_criteria>
- listByDate returns exceptions containing a specific date
- listByDateRange returns exceptions overlapping a range
- create validates endDate >= startDate
- create/update prevent overlapping exceptions
</success_criteria>

<output>
After completion, create `.planning/phases/02-professionals-services-calendar/02-07-SUMMARY.md`
</output>
