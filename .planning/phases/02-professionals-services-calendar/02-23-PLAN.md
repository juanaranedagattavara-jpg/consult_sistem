---
phase: 02-professionals-services-calendar
plan: 23
type: execute
wave: 7
depends_on: ["02-06", "02-07", "02-11"]
files_modified:
  - convex/availability.ts
autonomous: true

must_haves:
  truths:
    - "Availability action calculates slots for a date"
    - "Considers professional schedule or clinic default"
    - "Filters out exceptions (vacations)"
    - "Filters out existing appointments"
    - "Returns array of available time slots"
  artifacts:
    - path: "convex/availability.ts"
      provides: "Availability calculation action"
      exports: ["getSlots"]
  key_links:
    - from: "convex/availability.ts"
      to: "convex/lib/availability.ts"
      via: "import calculateAvailableSlots"
      pattern: "calculateAvailableSlots"
---

<objective>
Create availability action that calculates available slots.

Purpose: Core business logic for determining when a professional can see patients - used by bot and booking UI.
Output: convex/availability.ts action that returns available time slots.
</objective>

<execution_context>
@C:\Users\juana\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\juana\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-professionals-services-calendar/CONTEXT.md
@convex/lib/availability.ts
@convex/professionals.ts
@convex/professionalExceptions.ts
@convex/services.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create availability action</name>
  <files>convex/availability.ts</files>
  <action>
Create convex/availability.ts:

```typescript
import { v } from "convex/values";
import { action, internalQuery } from "./_generated/server";
import { internal } from "./_generated/api";
import { Id } from "./_generated/dataModel";
import {
  calculateAvailableSlots,
  getDayName,
  type DaySchedule,
  type CalendarEvent,
  type Exception,
} from "./lib/availability";

// Internal query to get all data needed for availability calculation
export const getAvailabilityData = internalQuery({
  args: {
    clinicId: v.id("clinics"),
    professionalId: v.id("professionals"),
    serviceId: v.id("services"),
    date: v.string(), // YYYY-MM-DD
  },
  handler: async (ctx, args) => {
    // Get clinic
    const clinic = await ctx.db.get(args.clinicId);
    if (!clinic) throw new Error("Clinica no encontrada");

    // Get professional
    const professional = await ctx.db.get(args.professionalId);
    if (!professional) throw new Error("Profesional no encontrado");
    if (professional.clinicId !== args.clinicId) {
      throw new Error("Profesional no pertenece a esta clinica");
    }

    // Get service
    const service = await ctx.db.get(args.serviceId);
    if (!service) throw new Error("Servicio no encontrado");
    if (service.clinicId !== args.clinicId) {
      throw new Error("Servicio no pertenece a esta clinica");
    }

    // Check if professional offers this service
    if (!professional.serviceIds.includes(args.serviceId)) {
      throw new Error("Este profesional no ofrece este servicio");
    }

    // Get exceptions for this professional
    const exceptions = await ctx.db
      .query("professionalExceptions")
      .withIndex("by_professional", (q) => q.eq("professionalId", args.professionalId))
      .collect();

    // TODO: Get existing appointments for this date
    // This will be implemented in Phase 3
    const existingAppointments: CalendarEvent[] = [];

    return {
      clinic,
      professional,
      service,
      exceptions,
      existingAppointments,
    };
  },
});

// Main action to get available slots
export const getSlots = action({
  args: {
    clinicId: v.id("clinics"),
    professionalId: v.id("professionals"),
    serviceId: v.id("services"),
    date: v.string(), // YYYY-MM-DD
  },
  handler: async (ctx, args) => {
    // Get all data
    const data = await ctx.runQuery(internal.availability.getAvailabilityData, args);

    // Build clinic schedule for the requested day
    const dayName = getDayName(args.date);
    const dayNum = new Date(args.date + "T00:00:00").getDay();
    const isWorkDay = data.clinic.workDays.includes(dayNum);

    const clinicSchedule: DaySchedule = {
      enabled: isWorkDay,
      start: data.clinic.hours.open,
      end: data.clinic.hours.close,
      lunch: data.clinic.hours.lunch,
    };

    // Get professional's schedule for this day (if custom)
    const professionalDaySchedule = data.professional.schedule?.[dayName as keyof typeof data.professional.schedule] ?? null;

    // Format exceptions
    const exceptions: Exception[] = data.exceptions.map((e) => ({
      startDate: e.startDate,
      endDate: e.endDate,
    }));

    // TODO: Fetch Google Calendar events via n8n webhook
    // For now, we only consider existing appointments from our system
    const calendarEvents: CalendarEvent[] = [];

    // If professional has calendarId, we would fetch events here
    // This will be implemented when n8n calendar integration is complete
    // if (data.professional.calendarId) {
    //   const events = await fetchCalendarEvents(data.professional.calendarId, args.date);
    //   calendarEvents.push(...events);
    // }

    // Calculate available slots
    const slots = calculateAvailableSlots(
      args.date,
      data.service.duration,
      professionalDaySchedule,
      clinicSchedule,
      exceptions,
      calendarEvents,
      data.existingAppointments,
      data.clinic.defaultSlotDuration // Use clinic's slot interval
    );

    return {
      date: args.date,
      professionalId: args.professionalId,
      serviceId: args.serviceId,
      serviceDuration: data.service.duration,
      slots,
    };
  },
});

// Helper to check if a specific slot is available (for booking validation)
export const isSlotAvailable = action({
  args: {
    clinicId: v.id("clinics"),
    professionalId: v.id("professionals"),
    serviceId: v.id("services"),
    date: v.string(), // YYYY-MM-DD
    time: v.string(), // HH:mm
  },
  handler: async (ctx, args) => {
    const result = await ctx.runAction(internal.availability.getSlots, {
      clinicId: args.clinicId,
      professionalId: args.professionalId,
      serviceId: args.serviceId,
      date: args.date,
    });

    const isAvailable = result.slots.some((slot) => slot.start === args.time);

    return { available: isAvailable };
  },
});
```

Key points:
- getAvailabilityData internal query fetches all needed data
- getSlots action uses pure functions from lib/availability.ts
- Handles professional schedule override vs clinic default
- Placeholder for Google Calendar integration (Phase 4 wires n8n) (wired in Phase 4)

**INTEGRATION NOTE (Phase 4 Scope):**
Google Calendar event fetching requires n8n webhook which is PHASE 4 scope.
Phase 2: Algorithm + placeholder for calendar events
Phase 4: Wire n8n webhook to fetch real calendar events

This allows full availability testing with appointments-only data.
- isSlotAvailable helper for booking validation
- Uses clinic's defaultSlotDuration for interval
  </action>
  <verify>
Run Convex to verify no errors:
```bash
npx convex dev --once
```
  </verify>
  <done>Availability action calculates slots with all considerations</done>
</task>

</tasks>

<verification>
1. `cat convex/availability.ts` shows action
2. `npx convex dev --once` succeeds
3. Action uses lib/availability.ts helpers
</verification>

<success_criteria>
- getSlots action returns array of { start, end } slots
- Considers professional schedule or clinic default
- Filters out exceptions (vacation days)
- Filters out existing appointments
- isSlotAvailable helper works for validation
- Placeholder for Google Calendar integration (Phase 4 wires n8n)
</success_criteria>

<output>
After completion, create `.planning/phases/02-professionals-services-calendar/02-23-SUMMARY.md`
</output>
