---
phase: 02-professionals-services-calendar
plan: 04
type: execute
wave: 2
depends_on: ["02-02"]
files_modified:
  - convex/serviceCategories.ts
autonomous: true

must_haves:
  truths:
    - "Can create service category for a clinic"
    - "Can list categories ordered by order field"
    - "Can update and delete categories"
    - "Can reorder categories"
  artifacts:
    - path: "convex/serviceCategories.ts"
      provides: "CRUD mutations and queries for service categories"
      exports: ["create", "list", "update", "remove", "reorder"]
  key_links:
    - from: "convex/serviceCategories.ts"
      to: "convex/schema.ts:serviceCategories"
      via: "ctx.db.insert/query"
      pattern: "ctx.db"
---

<objective>
Create service categories CRUD mutations and queries.

Purpose: Backend operations for managing service categories - categories group services and have manual ordering.
Output: convex/serviceCategories.ts with full CRUD + reorder functionality.
</objective>

<execution_context>
@C:\Users\juana\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\juana\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-professionals-services-calendar/CONTEXT.md
@convex/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create serviceCategories.ts with CRUD operations</name>
  <files>convex/serviceCategories.ts</files>
  <action>
Create convex/serviceCategories.ts with full CRUD:

```typescript
import { v } from "convex/values";
import { mutation, query } from "./_generated/server";

// List categories for a clinic, ordered by order field
export const list = query({
  args: { clinicId: v.id("clinics") },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("serviceCategories")
      .withIndex("by_clinic_order", (q) => q.eq("clinicId", args.clinicId))
      .collect();
  },
});

// Get single category
export const get = query({
  args: { categoryId: v.id("serviceCategories") },
  handler: async (ctx, args) => {
    return await ctx.db.get(args.categoryId);
  },
});

// Create new category
export const create = mutation({
  args: {
    clinicId: v.id("clinics"),
    name: v.string(),
  },
  handler: async (ctx, args) => {
    // Get highest order number for this clinic
    const existing = await ctx.db
      .query("serviceCategories")
      .withIndex("by_clinic", (q) => q.eq("clinicId", args.clinicId))
      .collect();
    const maxOrder = existing.length > 0
      ? Math.max(...existing.map(c => c.order))
      : -1;

    const now = Date.now();
    return await ctx.db.insert("serviceCategories", {
      clinicId: args.clinicId,
      name: args.name,
      order: maxOrder + 1,
      createdAt: now,
      updatedAt: now,
    });
  },
});

// Update category
export const update = mutation({
  args: {
    categoryId: v.id("serviceCategories"),
    name: v.string(),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.categoryId, {
      name: args.name,
      updatedAt: Date.now(),
    });
  },
});

// Delete category (will fail if services exist - handled in UI with warning)
export const remove = mutation({
  args: { categoryId: v.id("serviceCategories") },
  handler: async (ctx, args) => {
    // Check for services using this category
    const services = await ctx.db
      .query("services")
      .withIndex("by_category", (q) => q.eq("categoryId", args.categoryId))
      .first();

    if (services) {
      throw new Error("No se puede eliminar la categoria porque tiene servicios asociados");
    }

    await ctx.db.delete(args.categoryId);
  },
});

// Reorder categories (after drag-drop)
export const reorder = mutation({
  args: {
    clinicId: v.id("clinics"),
    categoryIds: v.array(v.id("serviceCategories")), // New order
  },
  handler: async (ctx, args) => {
    const now = Date.now();
    // Update order for each category based on array position
    for (let i = 0; i < args.categoryIds.length; i++) {
      await ctx.db.patch(args.categoryIds[i], {
        order: i,
        updatedAt: now,
      });
    }
  },
});
```

Key points:
- list uses by_clinic_order index for proper ordering
- create auto-calculates next order number
- remove checks for services first (prevents orphaned services)
- reorder takes array of IDs in new order
  </action>
  <verify>
Run Convex to verify no TypeScript errors:
```bash
npx convex dev --once
```
  </verify>
  <done>serviceCategories.ts exports list, get, create, update, remove, reorder</done>
</task>

</tasks>

<verification>
1. `cat convex/serviceCategories.ts` shows all 6 functions
2. `npx convex dev --once` succeeds
3. Mutations handle clinic scoping correctly
</verification>

<success_criteria>
- list query returns categories ordered by order field
- create mutation auto-assigns order number
- remove mutation prevents deletion if services exist
- reorder mutation updates all order fields
</success_criteria>

<output>
After completion, create `.planning/phases/02-professionals-services-calendar/02-04-SUMMARY.md`
</output>
